{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(moments)\n\nprimary_statistical_analysis <- function(vec, confidence_level = 0.95, vec_name = \"vec\") {\n  size_vec <- length(vec);\n  t_quantile <- qt((1 + confidence_level) / 2, size_vec - 1);\n  \n  mean_vec <- mean(vec);\n  sd_vec <- sd(vec);\n  #асимметрия\n  skewness_vec <- skewness(vec);\n  #эксцесс\n  kurtosis_vec <- kurtosis(vec);\n  \n  mean_deviation <- t_quantile*sd_vec/sqrt(size_vec);\n  sd_deviation <- t_quantile*sd_vec/sqrt(2*size_vec);\n  skewness_deviation <- t_quantile*sqrt(6*(size_vec - 2)/((size_vec + 1)*(size_vec + 3)));\n  kurtosis_deviation <-\n    t_quantile*sqrt(\n      24*size_vec*(size_vec - 2)*(size_vec - 3)\n      /\n      (((size_vec + 1)^2)*(size_vec + 3)*(size_vec + 5))\n    );\n  \n  cat(\n    vec_name,\":\\n\",\n    \"\\tmean(\", vec_name, \") = \", mean_vec,\"\\n\",\n    \"\\tconfidence interval = (\", mean_vec - mean_deviation, \", \", mean_vec + mean_deviation, \")\\n\",\n    \"\\n\",\n    \"\\tstandard deviation(\", vec_name, \") = \", sd_vec,\"\\n\",\n    \"\\tconfidence interval = (\", sd_vec - sd_deviation, \", \", sd_vec + sd_deviation, \")\\n\",\n    \"\\n\",\n    \"\\tskewness(\", vec_name, \") = \", skewness_vec,\"\\n\",\n    \"\\tconfidence interval = (\", skewness_vec - skewness_deviation, \", \", skewness_vec + skewness_deviation, \")\\n\",\n    \"\\n\",\n    \"\\tkurtosis(\", vec_name, \") = \", kurtosis_vec,\"\\n\",\n    \"\\tconfidence interval = (\", kurtosis_vec - kurtosis_deviation, \", \", kurtosis_vec + kurtosis_deviation, \")\\n\",\n    \"\\n\",\n    sep = \"\"\n  )\n}\n\ncorrelation_ratio_test <- function(my_table, points_from_range_, confidence_level = 0.95) {\n  my_table_x_range <- range(my_table[[1]]);\n  points_from_range <- sort(split(points_from_range_, sapply(points_from_range_, function(arg) {\n    if (arg >= my_table_x_range[1] && arg <= my_table_x_range[2]){\n      return (1);\n    }\n    return(0);\n  }))$'1');\n  \n  if (points_from_range[1] != my_table_x_range[1]) points_from_range <- c(my_table_x_range[1], points_from_range);\n  points_from_range_length <- length(points_from_range);\n  if (points_from_range[points_from_range_length] != my_table_x_range[2]) {\n    points_from_range <- c(points_from_range, my_table_x_range[2]);\n    points_from_range_length <- points_from_range_length + 1;\n  }\n  \n  ranges <- matrix(nrow = points_from_range_length - 1, ncol = 2);\n  \n  for(n in 1:(points_from_range_length - 1)) {\n    ranges[n,] <- c(points_from_range[n], points_from_range[n + 1]);\n  }\n  \n  my_table_length <- length(my_table[[1]]);\n  ranges_length <- points_from_range_length - 1;\n  range_numbers <- array(dim = my_table_length);\n  \n  n <- 1;\n  while (n <= my_table_length) {\n    if (is.na(my_table[n, 1])){\n      range_numbers[n] <- NA;\n      n <- n + 1;\n      next;\n    }\n    range_number <- 1;\n    while(range_number <= (ranges_length - 1)){\n      if (\n          (ranges[range_number, 1] <= my_table[n, 1]) &&\n          (my_table[n, 1] < ranges[range_number, 2])\n        ){\n        break;\n      }\n      range_number <- range_number + 1;\n    }\n    range_numbers[n] <- range_number;\n    n <- n + 1;\n  }\n  \n  averages <- tapply(1:my_table_length, range_numbers, function(my_table_part) {\n    mean(my_table[[2]][my_table_part]);\n  });\n  \n  ratio <- (\n    sd(sapply(range_numbers, function(range_number){\n      averages[as.character(range_number)];\n    }))\n    /\n    sd(my_table[[2]])\n  )^2;\n  \n  result <- list();\n  \n  result$data.description <- cat(paste(\"data: \", colnames(my_table)[1], \"and\", colnames(my_table)[2]));\n  \n  df1 <- ranges_length - 1;\n  df2 <- my_table_length - ranges_length;\n  \n  result$test.f <- (ratio/df1)/((1 - ratio)/df2);\n  result$test.df1 <- df1;\n  result$test.df2 <- df2;\n  result$test.f_quantile <- qf(confidence_level, df1, df2);\n  result$test.p_val <- 1 - pf(result$test.f, df1, df2);\n  \n  if (result$test.f <= result$test.f_quantile) {#H0\n    result$hypothesis.main <- TRUE;\n    result$hypothesis.alternative <- FALSE;\n    result$hypothesis.description <- \"main hypothesis: true ratio is equal to 0\";\n  } else {#H1\n    result$hypothesis.main <- FALSE;\n    result$hypothesis.alternative <- TRUE;\n    result$hypothesis.description <- \"alternative hypothesis: true ratio is not equal to 0\";\n  }\n  \n  result$conf.level <- confidence_level;\n  #ratio = 1 - 1/(f*(df1 / df2) + 1)\n  result$conf.int <- 1 - 1/(c(qf((1 - confidence_level)/2, df1, df2), qf((1 + confidence_level)/2, df1, df2)) * (df1 / df2) + 1);\n  \n  result$conf.description <- cat(paste(result$conf.level, \"percent confidence interval:\", result$conf.int));\n  \n  result$ratio.estimate <- ratio;\n  result$ratio.description <- cat(paste(\"ratio estimate:\", result$ratio.estimate));\n  \n  return (result);\n};\n\nshinyServer(function(input, output) {\n  \n  # By declaring get_my_table as a reactive expression we ensure \n  # that:\n  #\n  #  1) It is only called when the inputs it depends on changes\n  #  2) The computation and result are shared by all the callers \n  #\t  (it only executes a single time)\n  #\n  get_my_table <- reactive({\n    result <- NULL;\n    if (!is.null(input$file1) && !is.null(input$file1$datapath)){\n      result <- read.table(input$file1$datapath, header=input$header, sep=input$sep);\n      if (!input$header) {\n        colnames(result) <- c('x', 'y');\n      }\n    }\n    return(result);\n  });\n   \n  #* **1.**\tПобудову кореляційного поля\n  output$correlation_field <- renderPlot({\n    my_table <- get_my_table();\n    if (!is.null(my_table)){\n      return(plot(my_table));\n      #return(hist(my_table[[2]]));\n      #return(hist(log(my_table[[1]])));\n      #return(plot(log(my_table[[1]]), my_table[[2]]));\n      #return(plot(my_table[[1]], exp(my_table[[2]])));\n    }\n    return(NULL);\n  })\n  \n  #і проведення первинного статистичного аналізу окремих ознак об’єкта (точкове та інтервальне оцінювання середнього, середньоквадратичного, коефіцієнтів асиметрії та ексцесу).\n  output$primary_statistical_analysis <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    cat(\n      cat(\"sample size is\", length(my_table[[1]]), \"\\n\\n\"),\n      primary_statistical_analysis(my_table[[1]], input$confidence_level, colnames(my_table)[1]),\n      cat(\"\\n\"),\n      primary_statistical_analysis(my_table[[2]], input$confidence_level, colnames(my_table)[2]),\n      sep = \"\"\n    );\n  })\n  \n  #* 2.1.\tзнаходження оцінки коефіцієнта кореляції, перевірку його значущості та призначення довірчого інтервалу (у випадку значущості);\n  output$Pearson_correlation_test <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"pearson\");\n    cor_test$data.name <- paste(colnames(my_table)[1], \"and\", colnames(my_table)[2]);\n    return(cor_test);\n  })\n  \n  #* 2.2.\tобчислення коефіцієнта кореляційного відношення та перевірку його значущості;\n  \n  #* 2.3.\tпідрахунок рангових коефіцієнтів кореляції Спірмена та Кендалла та перевірку їх значущості.\n  output$Spearman_correlation_test <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"spearman\");\n    cor_test$data.name <- paste(colnames(my_table)[1], \"and\", colnames(my_table)[2]);\n    return(cor_test);\n  })\n  \n  output$Kendall_correlation_test <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    cor_test <- cor.test(my_table[[1]], my_table[[2]], conf.level = input$confidence_level, method = \"kendall\");\n    cor_test$data.name <- paste(colnames(my_table)[1], \"and\", colnames(my_table)[2]);\n    return(cor_test);\n  })\n  \n  output$min_max <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    return(cat(\n      paste0(\"[min(\", colnames(my_table)[1], \"); max(\", colnames(my_table)[1], \")]   =   [\", min(my_table[[1]]), \"; \", max(my_table[[1]]), \"]\")\n    ));\n  })\n  \n  output$select_file_text <- renderPrint({\n    my_table <- get_my_table();\n    if (is.null(my_table)) return(NULL);\n    \n    return(cat(\n      paste0(\"Select file with vector of numbers from range [\", min(my_table[[1]]), \"; \", max(my_table[[1]]), \"]\")\n    ));\n  })\n  \n  output$correlation_ratio_test <- renderText({\n    my_table <- get_my_table();\n    if (is.null(my_table) || is.null(input$set_own_subranges)) return(NULL);\n    \n    subranges <- c();\n    \n    if (!input$set_own_subranges) {\n      my_table_x_range <- range(my_table[[1]]);\n      if (input$subrange_number <= 1) {\n        subranges <- my_table_x_range;\n      } else {\n        range_length = (my_table_x_range[2] - my_table_x_range[1]) / input$subrange_number;\n        for (n in 0:(input$subrange_number - 1)){\n          subranges <- c(subranges, my_table_x_range[1] + n*range_length);\n        }\n        subranges <- c(subranges, my_table_x_range[2]);\n      }\n    } else {\n      if (!is.null(input$file2_ranges) && !is.null(input$file2_ranges$datapath)){\n        subranges <- read.table(input$file2_ranges$datapath, header=FALSE, sep='')[[1]];\n      } else return(NULL);\n    }\n    \n    return(correlation_ratio_test(my_table, subranges, input$confidence_level));\n  })\n})\n",
    "created" : 1481006344467.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "3|90|40|0|\n136|37|256|0|\n",
    "hash" : "3590359235",
    "id" : "C1AF4B84",
    "lastKnownWriteTime" : 1481083003,
    "last_content_update" : 1481083012391,
    "path" : "D:/Книги/Прога/7 семестр/Випадкові процеси/DataAnalysisLab1/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineSize" : "72.9956574312099",
        "docOutlineVisible" : "0"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}